<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>自定义Promise测试</title>
</head>
<body>
<script type="text/javascript" src="./Promise.js"></script>
<!--

<script type="text/javascript">
  const p = new Promise((resolve, reject) => { // excutor

    // 模拟做异步处理
    setTimeout(() => {
      if(Date.now()%2===0) {// 如果成功了, 调用 resolve()
        resolve('成功数据')
      } else { // 如果失败了, 调用 reject()
        reject('失败原因数据')
      }
    }, 100)

  })
  console.log('new Promise() 之后')

  p.then(value => {

  }, reason => {

  })
  p.then(value => {

  }, reason => {

  })
</script>
-->
<!--
<script type="text/javascript">
  new Promise((resolve, reject) => { // excutor
    // resolve(1) // 先修改状态为成功并保存数据, 后面指定的回调函数, 只调用成功的onResolved回调函数(异步)
    reject(1) // 先修改状态为失败并保存数据, 后面指定的回调函数, 只调用失败的onRejected回调函数(异步)
    /*setTimeout(() => { // 先指定回调函数, 内部需要先保存回调函数, 后面resolve()内部修改状态, 保存数据, 调用回调函数(异步)
      resolve(1)
    })*/
  }).then(value => {
    console.log('p1 onResolved()', value)
    return 2
    // throw 3
    // return Promise.resolve(4)
    // return Promise.reject(4)
  }, reason => {
    console.log('p1 onRejected()', reason)
    // return 2
    //return Promise.resolve(4)
    // return Promise.reject(4)
  }).then(value => {
    console.log('p2 onResolved()', value)
    throw 5
  }, reason => {
    console.log('p2 onRejected()', reason)
  }).catch(reason => {
    console.log('p3 onRejected()', reason)
  })
</script>-->
<!--
then()返回的promise的状态和结果数据由当前promise对象的回调函数的返回值
  1. 抛出异常  ===> 返回的promise变为rejected
  2. 返回一个新的promise ===> 得到新的promise的结果值作为返回的promise的结果值
  3. 返回一个一般值(undefined) ===> 将这个值作为返回的promise的成功值
-->


<script type="text/javascript">
  const p1 = Promise.resolve(1)
  const p2 = Promise.resolve('atguigu')
  const p3 = Promise.reject(2)

  Promise.all([p1, p2, 3, p3]).then(values => {
    console.log(values)
  }, reason => {
    console.log(reason)
  })
</script>


</body>
</html>